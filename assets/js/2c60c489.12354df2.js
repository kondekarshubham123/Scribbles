"use strict";(self.webpackChunkscribbles=self.webpackChunkscribbles||[]).push([[9698],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var l=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,l,a=function(e,n){if(null==e)return{};var t,l,a={},i=Object.keys(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=l.createContext({}),h=function(e){var n=l.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=h(e.components);return l.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return l.createElement(l.Fragment,{},n)}},c=l.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=h(t),c=a,m=u["".concat(s,".").concat(c)]||u[c]||p[c]||i;return t?l.createElement(m,o(o({ref:n},d),{},{components:t})):l.createElement(m,o({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=c;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:a,o[1]=r;for(var h=2;h<i;h++)o[h]=t[h];return l.createElement.apply(null,o)}return l.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var l=t(7462),a=(t(7294),t(3905));const i={},o="Pattern 3: Fast & Slow pointers",r={unversionedId:"category/notes/\u2705  Pattern 03: Fast & Slow pointers",id:"category/notes/\u2705  Pattern 03: Fast & Slow pointers",title:"Pattern 3: Fast & Slow pointers",description:"The Fast & Slow pointer approach, also known as the Hare & Tortoise algorithm, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic LinkedLists or arrays.",source:"@site/dsa/category/notes/\u2705  Pattern 03: Fast & Slow pointers.md",sourceDirName:"category/notes",slug:"/category/notes/\u2705  Pattern 03: Fast & Slow pointers",permalink:"/Scribbles/dsa/category/notes/\u2705  Pattern 03: Fast & Slow pointers",draft:!1,editUrl:"https://github.com/kondekarshubham123/Scribbles/tree/main/dsa/category/notes/\u2705  Pattern 03: Fast & Slow pointers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pattern 2: Two Pointers",permalink:"/Scribbles/dsa/category/notes/\u2705  Pattern 02: Two Pointers"},next:{title:"Pattern 4 : Merge Intervals",permalink:"/Scribbles/dsa/category/notes/\u2705  Pattern 04 : Merge Intervals"}},s={},h=[{value:"LinkedList Cycle (easy)",id:"linkedlist-cycle-easy",level:2},{value:"Start of LinkedList Cycle (medium)",id:"start-of-linkedlist-cycle-medium",level:2},{value:"Happy Number (medium)",id:"happy-number-medium",level:2},{value:"Middle of the LinkedList (easy)",id:"middle-of-the-linkedlist-easy",level:2},{value:"\ud83c\udf1f Palindrome LinkedList (medium)",id:"-palindrome-linkedlist-medium",level:2},{value:"\ud83c\udf1f Rearrange a LinkedList (medium)",id:"-rearrange-a-linkedlist-medium",level:2},{value:"Example 1:",id:"example-1-1",level:3},{value:"Example 2:",id:"example-2-1",level:3},{value:"\ud83c\udf1f Cycle in a Circular Array (hard)",id:"-cycle-in-a-circular-array-hard",level:2},{value:"Example 1:",id:"example-1-2",level:3},{value:"Example 2:",id:"example-2-2",level:3},{value:"Example 3:",id:"example-3",level:3},{value:"An Alternate Approach",id:"an-alternate-approach",level:4}],d={toc:h};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,l.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pattern-3-fast--slow-pointers"},"Pattern 3: Fast & Slow pointers"),(0,a.kt)("p",null,"The ",(0,a.kt)("b",null,"Fast & Slow")," pointer approach, also known as the ",(0,a.kt)("b",null,"Hare & Tortoise algorithm"),", is a pointer algorithm that uses two pointers which move through the array (or sequence/",(0,a.kt)("b",null,"LinkedList"),") at different speeds. This approach is quite useful when dealing with cyclic ",(0,a.kt)("b",null,"LinkedLists")," or arrays."),(0,a.kt)("p",null,"By moving at different speeds (say, in a cyclic ",(0,a.kt)("b",null,"LinkedList"),"), the algorithm proves that the two pointers are bound to meet. The ",(0,a.kt)("i",null,"fast pointer")," should catch the ",(0,a.kt)("i",null,"slow pointer")," once both the pointers are in a cyclic loop."),(0,a.kt)("p",null,"One of the famous problems solved using this technique was ",(0,a.kt)("b",null,"Finding a ",(0,a.kt)("i",null,"cycle")," in a LinkedList"),". Let\u2019s jump onto this problem to understand the ",(0,a.kt)("b",null,"Fast & Slow")," pattern."),(0,a.kt)("h2",{id:"linkedlist-cycle-easy"},"LinkedList Cycle (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/linked-list-cycle/"},"https://leetcode.com/problems/linked-list-cycle/")),(0,a.kt)("p",null,"Imagine two racers running in a circular racing track. If one racer is faster than the other, the faster racer is bound to catch up and cross the slower racer from behind. We can use this fact to devise an algorithm to determine if a ",(0,a.kt)("b",null,"LinkedList")," has a  ",(0,a.kt)("i",null,"cycle"),"  in it or not."),(0,a.kt)("p",null,"Imagine we have a slow and a ",(0,a.kt)("i",null,"fast pointer")," to traverse the ",(0,a.kt)("b",null,"LinkedList"),". In each iteration, the ",(0,a.kt)("i",null,"slow pointer")," moves one step and the ",(0,a.kt)("i",null,"fast pointer")," moves two steps. This gives us two conclusions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If the ",(0,a.kt)("b",null,"LinkedList")," doesn\u2019t have a  ",(0,a.kt)("i",null,"cycle"),"  in it, the ",(0,a.kt)("i",null,"fast pointer")," will reach the end of the ",(0,a.kt)("b",null,"LinkedList")," before the ",(0,a.kt)("i",null,"slow pointer")," to reveal that there is no  ",(0,a.kt)("i",null,"cycle"),"  in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("i",null,"slow pointer")," will never be able to catch up to the ",(0,a.kt)("i",null,"fast pointer")," if there is no  ",(0,a.kt)("i",null,"cycle"),"  in the ",(0,a.kt)("b",null,"LinkedList"),".")),(0,a.kt)("p",null,"If the ",(0,a.kt)("b",null,"LinkedList")," has a cycle, the ",(0,a.kt)("i",null,"fast pointer")," enters the  ",(0,a.kt)("i",null,"cycle"),"  first, followed by the ",(0,a.kt)("i",null,"slow pointer"),". After this, both pointers will keep moving in the  ",(0,a.kt)("i",null,"cycle"),"  infinitely. If at any stage both of these pointers meet, we can conclude that the ",(0,a.kt)("b",null,"LinkedList")," has a  ",(0,a.kt)("i",null,"cycle"),"  in it. Let\u2019s analyze if it is possible for the two pointers to meet. When the ",(0,a.kt)("i",null,"fast pointer")," is approaching the ",(0,a.kt)("i",null,"slow pointer")," from behind we have two possibilities:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("i",null,"fast pointer")," is one step behind the ",(0,a.kt)("i",null,"slow pointer"),"."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("i",null,"fast pointer")," is two steps behind the ",(0,a.kt)("i",null,"slow pointer"),".")),(0,a.kt)("p",null,"All other distances between the fast and ",(0,a.kt)("i",null,"slow pointers")," will reduce to one of these two possibilities. Let\u2019s analyze these scenarios, considering the ",(0,a.kt)("i",null,"fast pointer")," always moves first:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If the ",(0,a.kt)("i",null,"fast pointer")," is one step behind the ",(0,a.kt)("i",null,"slow pointer"),": The ",(0,a.kt)("i",null,"fast pointer")," moves two steps and the ",(0,a.kt)("i",null,"slow pointer")," moves one step, and they both meet."),(0,a.kt)("li",{parentName:"ol"},"If the ",(0,a.kt)("i",null,"fast pointer")," is two steps behind the ",(0,a.kt)("i",null,"slow pointer"),": The ",(0,a.kt)("i",null,"fast pointer")," moves two steps and the ",(0,a.kt)("i",null,"slow pointer")," moves one step. After the moves, the ",(0,a.kt)("i",null,"fast pointer")," will be one step behind the ",(0,a.kt)("i",null,"slow pointer"),", which reduces this scenario to the first scenario. This means that the two pointers will meet in the next iteration.")),(0,a.kt)("p",null,"This concludes that the two pointers will definitely meet if the ",(0,a.kt)("b",null,"LinkedList")," has a cycle. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next\n  }\n}\n\nfunction hasCycle(head) {\n  let slow = head\n  let fast = head\n  while(fast !== null && fast.next !== null) {\n    fast = fast.next.next;\n    slow = slow.next\n    \n    if(slow === fast) {\n      //found the cycle\n      return true\n    }\n  }\n  return false\n}\n\nhead = new Node(1)\nhead.next = new Node(2)\nhead.next.next = new Node(3)\nhead.next.next.next = new Node(4)\nhead.next.next.next.next = new Node(5)\nhead.next.next.next.next.next = new Node(6)\nconsole.log(`LinkedList has cycle: ${hasCycle(head)}`)\n\nhead.next.next.next.next.next.next = head.next.next\nconsole.log(`LinkedList has cycle: ${hasCycle(head)}`)\n\nhead.next.next.next.next.next.next = head.next.next.next\nconsole.log(`LinkedList has cycle: ${hasCycle(head)}`)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Once the ",(0,a.kt)("i",null,"slow pointer")," enters the cycle, the ",(0,a.kt)("i",null,"fast pointer")," will meet the ",(0,a.kt)("i",null,(0,a.kt)("i",null,"slow pointer"))," in the same loop. Therefore, the time complexity of our algorithm will be ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is the total number of nodes in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given the head of a LinkedList with a cycle, find the length of the cycle.")),(0,a.kt)("p",null,"Once the fast and ",(0,a.kt)("i",null,"slow pointers")," meet, we can save the ",(0,a.kt)("i",null,"slow pointer")," and iterate the whole  ",(0,a.kt)("i",null,"cycle"),"  with another pointer until we see the ",(0,a.kt)("i",null,"slow pointer")," again to find the length of the cycle."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next\n  }\n}\n\nfunction findCycleLength(head) {\n  let slow = head\n  let fast = head\n  \n  while(fast !== null && fast.next !== null) {\n    fast = fast.next.next;\n    slow = slow.next\n    \n    if(slow === fast) {\n      //found the cycle\n      return calculateCycleLength(slow)\n    }\n  }\n  return 0\n}\n\nfunction calculateCycleLength(slow) {\n  let current = slow\n  let cycleLength = 0\n  \n  while(true) {\n    current = current.next\n    cycleLength++\n    if(current === slow) {\n      break\n    }\n  }\n  return cycleLength\n}\n\nhead = new Node(1)\nhead.next = new Node(2)\nhead.next.next = new Node(3)\nhead.next.next.next = new Node(4)\nhead.next.next.next.next = new Node(5)\nhead.next.next.next.next.next = new Node(6)\nconsole.log(`LinkedList has cycle length of: ${findCycleLength(head)}`)\n\nhead.next.next.next.next.next.next = head.next.next\nconsole.log(`LinkedList has cycle length of: ${findCycleLength(head)}`)\n\nhead.next.next.next.next.next.next = head.next.next.next\nconsole.log(`LinkedList has cycle length of: ${findCycleLength(head)}`)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The above algorithm runs in ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," time complexity and ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)")," space complexity.")),(0,a.kt)("h2",{id:"start-of-linkedlist-cycle-medium"},"Start of LinkedList Cycle (medium)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/linked-list-cycle-ii/"},"https://leetcode.com/problems/linked-list-cycle-ii/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given the head of a ",(0,a.kt)("b",null,"Singly LinkedList")," that contains a cycle, write a function to find the ",(0,a.kt)("b",null,"starting node of the cycle"),".")),(0,a.kt)("p",null,"If we know the length of the ",(0,a.kt)("b",null,"LinkedList")," cycle, we can find the start of the  ",(0,a.kt)("i",null,"cycle"),"  through the following steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Take two pointers. Let\u2019s call them ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer1")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer2"),"."),(0,a.kt)("li",{parentName:"ol"},"Initialize both pointers to point to the start of the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ol"},"We can find the length of the ",(0,a.kt)("b",null,"LinkedList"),"  ",(0,a.kt)("i",null,"cycle"),"  using the approach discussed in ",(0,a.kt)("b",null,"LinkedList Cycle"),". Let\u2019s assume that the length of the  ",(0,a.kt)("i",null,"cycle"),"  is ",(0,a.kt)("inlineCode",{parentName:"li"},"K")," nodes."),(0,a.kt)("li",{parentName:"ol"},"Move ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer2")," ahead by ",(0,a.kt)("inlineCode",{parentName:"li"},"K")," nodes."),(0,a.kt)("li",{parentName:"ol"},"Now, keep incrementing ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer1")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer2")," until they both meet."),(0,a.kt)("li",{parentName:"ol"},"As ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer2")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"K")," nodes ahead of ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer1"),", which means, ",(0,a.kt)("inlineCode",{parentName:"li"},"pointer2")," must have completed one loop in the  ",(0,a.kt)("i",null,"cycle"),"  when both pointers meet. Their meeting point will be the start of the cycle.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next\n  }\n}\n\nfunction findCycleStart(head) {\n  let cycleLength = 0\n  let slow = head\n  let fast = head\n   while((fast !== null && fast.next !== null)){\n     fast = fast.next.next\n     slow = slow.next\n     \n     if(slow === fast) {\n       //found the cycle\n       cycleLength = calculateCycleLength(slow)\n       break\n     }\n   }\n  \n  return findStart(head, cycleLength)\n};\n\n\nfunction calculateCycleLength(slow) {\n  let current = slow\n  let cycleLength = 0\n  \n  while(true) {\n    current = current.next\n    cycleLength++\n    if(current === slow) {\n      break\n    }\n  }\n  return cycleLength\n}\n\nfunction findStart(head, cycleLength) {\n  let pointer1 = head\n  let pointer2 = head\n  //move pointer2 ahead by cycleLength nodes\n  while(cycleLength > 0) {\n    pointer2 = pointer2.next\n    cycleLength--\n  }\n  \n  //increment both pointers until they meet at the start\n  //of the cycle\n  while(pointer1 !== pointer2) {\n    pointer1 = pointer1.next\n    pointer2 = pointer2.next\n  }\n  return pointer1\n}\n\nhead = new Node(1)\nhead.next = new Node(2)\nhead.next.next = new Node(3)\nhead.next.next.next = new Node(4)\nhead.next.next.next.next = new Node(5)\nhead.next.next.next.next.next = new Node(6)\n\nhead.next.next.next.next.next.next = head.next.next\nconsole.log(`LinkedList cycle start: ${findCycleStart(head).value}`)\n\nhead.next.next.next.next.next.next = head.next.next.next\nconsole.log(`LinkedList cycle start: ${findCycleStart(head).value}`)\n\nhead.next.next.next.next.next.next = head\nconsole.log(`LinkedList cycle start: ${findCycleStart(head).value}`)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"As we know, finding the  ",(0,a.kt)("i",null,"cycle"),"  in a ",(0,a.kt)("b",null,"LinkedList")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," nodes and also finding the length of the  ",(0,a.kt)("i",null,"cycle"),"  requires ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)"),". Also, as we saw in the above algorithm, we will need ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," to find the start of the cycle. Therefore, the overall time complexity of our algorithm will be ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"happy-number-medium"},"Happy Number (medium)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/happy-number/"},"https://leetcode.com/problems/happy-number/")),(0,a.kt)("p",null,"Any number will be called a ",(0,a.kt)("b",null,"happy number")," if, after repeatedly replacing it with a number equal to the ",(0,a.kt)("b",null,"sum of the square of all of its digits, leads us to number ",(0,a.kt)("inlineCode",{parentName:"p"},"1")),". All other ",(0,a.kt)("b",null,"(not-happy)")," numbers will never reach ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),". Instead, they will be stuck in a  ",(0,a.kt)("i",null,"cycle"),"  of numbers which does not include ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,"The process, defined above, to find out if a number is a ",(0,a.kt)("b",null,"happy number")," or not, always ends in a cycle. If the number is a ",(0,a.kt)("b",null,"happy number"),", the process will be stuck in a  ",(0,a.kt)("i",null,"cycle"),"  on number ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", and if the number is not a ",(0,a.kt)("b",null,"happy number")," then the process will be stuck in a  ",(0,a.kt)("i",null,"cycle"),"  with a set of numbers. As we saw in Example-2 while determining if ",(0,a.kt)("inlineCode",{parentName:"p"},"12")," is a ",(0,a.kt)("b",null,"happy number")," or not, our process will get stuck in a  ",(0,a.kt)("i",null,"cycle"),"  with the following numbers: ",(0,a.kt)("inlineCode",{parentName:"p"},"89 -> 145 -> 42 -> 20 -> 4 -> 16 -> 37 -> 58 -> 89")),(0,a.kt)("p",null,"We saw in the ",(0,a.kt)("b",null,"LinkedList Cycle")," problem that we can use the ",(0,a.kt)("b",null,"Fast & Slow")," pointers method to find a  ",(0,a.kt)("i",null,"cycle"),"  among a set of elements. As we have described above, each number will definitely have a cycle. Therefore, we will use the same ",(0,a.kt)("i",null,"fast")," & ",(0,a.kt)("i",null,"slow pointer")," strategy to find the  ",(0,a.kt)("i",null,"cycle"),"  and once the  ",(0,a.kt)("i",null,"cycle"),"  is found, we will see if the  ",(0,a.kt)("i",null,"cycle"),"  is stuck on number ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to find out if the number is happy or not."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findHappyNumber(num) {\n  let slow = num\n  let fast = num\n  \n  while(true) {\n    //move one step\n    slow = findSquareSum(slow)\n    //move two steps\n    fast = findSquareSum(findSquareSum(fast))\n    \n    if(slow === fast) {\n      //found the cycle\n      break\n    }\n  }\n  //see if the cycle is stuck on the number 1\n  return slow === 1\n}\n\nfunction findSquareSum(num) {\n  let sum = 0\n  while(num > 0) {\n    let digit = num % 10\n    sum += digit * digit\n    num = Math.floor(num / 10)\n  }\n  return sum\n  \n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"findHappyNumber(23)//true")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"23")," is a ",(0,a.kt)("b",null,"happy number"),", Here are the steps to find out that ",(0,a.kt)("inlineCode",{parentName:"p"},"23")," is a ",(0,a.kt)("b",null,"happy number"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"2\xb2 + 3\xb2 = 4 + 9 = 13"),(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 3\xb2 = 1 + 9 = 10"),(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 0\xb2 = 1 + 0 = 1")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"findHappyNumber(12)//false")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"12")," is not a ",(0,a.kt)("b",null,"happy number"),", Here are the steps to find out that ",(0,a.kt)("inlineCode",{parentName:"p"},"12")," is not a ",(0,a.kt)("b",null,"happy number"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"1\xb2+2\xb2= 1 + 4 = 5"),(0,a.kt)("li",{parentName:"ol"},"5\xb2 = 25"),(0,a.kt)("li",{parentName:"ol"},"2\xb2 + 5\xb2 = 4 + 25 = 29"),(0,a.kt)("li",{parentName:"ol"},"2\xb2 + 9\xb2 = 4 + 81 = 85"),(0,a.kt)("li",{parentName:"ol"},"8\xb2 + 5\xb2 = 64 + 25 = 89"),(0,a.kt)("li",{parentName:"ol"},"8\xb2 + 9\xb2 = 64 + 81 = 145"),(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 4\xb2 + 5\xb2= 1 + 16 + 25 = 42"),(0,a.kt)("li",{parentName:"ol"},"4\xb2 + 2\xb2 = 16 + 4 = 20"),(0,a.kt)("li",{parentName:"ol"},"2\xb2 + 0\xb2 = 4 + 0 = 4"),(0,a.kt)("li",{parentName:"ol"},"4\xb2= 16"),(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 6\xb2 = 1 + 36 = 37"),(0,a.kt)("li",{parentName:"ol"},"3\xb2 + 7\xb2 = 9 + 49 = 58"),(0,a.kt)("li",{parentName:"ol"},"5\xb2 + 8\xb2= 25 + 64 = 89\nStep ",(0,a.kt)("inlineCode",{parentName:"li"},"13")," leads us back to step ",(0,a.kt)("inlineCode",{parentName:"li"},"5")," as the number becomes equal to ",(0,a.kt)("inlineCode",{parentName:"li"},"89\u2019, this means that we can never reach "),"1",(0,a.kt)("inlineCode",{parentName:"li"},", therefore, "),"12` is not a ",(0,a.kt)("b",null,"happy number"),".")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"findHappyNumber(19)//true")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"19")," is a ",(0,a.kt)("b",null,"happy number"),", Here are the steps to find out that 19 is a ",(0,a.kt)("b",null,"happy number"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 9\xb2 = 82"),(0,a.kt)("li",{parentName:"ol"},"8\xb2 + 2\xb2 = 68"),(0,a.kt)("li",{parentName:"ol"},"6\xb2 + 8\xb2 = 100"),(0,a.kt)("li",{parentName:"ol"},"1\xb2 + 0\xb2 + 0\xb2 = 1")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"findHappyNumber(2)//false")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"2")," is not a ",(0,a.kt)("b",null,"happy number")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the algorithm is difficult to determine. However we know the fact that all ",(0,a.kt)("b",null,"unhappy number"),"s eventually get stuck in the cycle: 4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4")),(0,a.kt)("p",null,"This sequence behavior tells us two things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If the number ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is less than or equal to ",(0,a.kt)("inlineCode",{parentName:"li"},"1000"),", then we reach the  ",(0,a.kt)("i",null,"cycle"),"  or ",(0,a.kt)("inlineCode",{parentName:"li"},"1")," in at most ",(0,a.kt)("inlineCode",{parentName:"li"},"1001")," steps."),(0,a.kt)("li",{parentName:"ol"},"For ",(0,a.kt)("inlineCode",{parentName:"li"},"N > 1000"),", suppose the number has ",(0,a.kt)("inlineCode",{parentName:"li"},"M")," digits and the next number is ",(0,a.kt)("inlineCode",{parentName:"li"},"N1"),". From the above Wikipedia link, we know that the sum of the squares of the digits of ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is at most ",(0,a.kt)("inlineCode",{parentName:"li"},"9\xb2M"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"81M"),"(this will happen when all digits of ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," are ",(0,a.kt)("inlineCode",{parentName:"li"},"9"),").")),(0,a.kt)("p",null,"This means:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"N1 < 81M")),(0,a.kt)("li",{parentName:"ol"},"As we know ",(0,a.kt)("inlineCode",{parentName:"li"},"M = log(N+1)")),(0,a.kt)("li",{parentName:"ol"},"Therefore: ",(0,a.kt)("inlineCode",{parentName:"li"},"N1 < 81 * log(N+1) => N1 = O(logN)"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"This concludes that the above algorithm will have a time complexity of ",(0,a.kt)("inlineCode",{parentName:"li"},"O(logN)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"middle-of-the-linkedlist-easy"},"Middle of the LinkedList (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/middle-of-the-linked-list/"},"https://leetcode.com/problems/middle-of-the-linked-list/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given the head of a ",(0,a.kt)("b",null,"Singly LinkedList"),", write a method to return the ",(0,a.kt)("b",null,"middle node")," of the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("p",{parentName:"blockquote"},"If the total number of nodes in the ",(0,a.kt)("b",null,"LinkedList")," is even, return the second middle node.")),(0,a.kt)("p",null,"One brute force strategy could be to first count the number of nodes in the ",(0,a.kt)("b",null,"LinkedList")," and then find the middle node in the second iteration. Can we do this in one iteration?"),(0,a.kt)("p",null,"We can use the ",(0,a.kt)("b",null,"Fast & Slow")," pointers method such that the ",(0,a.kt)("i",null,"fast pointer")," is always twice the nodes ahead of the ",(0,a.kt)("i",null,"slow pointer"),". This way, when the ",(0,a.kt)("i",null,"fast pointer")," reaches the end of the ",(0,a.kt)("b",null,"LinkedList"),", the ",(0,a.kt)("i",null,"slow pointer")," will be pointing at the middle node."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n  constructor(value, next = null) {\n    this.value = value\n    this.next = next\n  }\n}\n\nfunction findMiddleOfLinkedList(head) {\n  let slow = head\n  let fast = head\n  \n  while(fast !== null && fast.next !== null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  return slow\n}\n\nhead = new Node(1)\nhead.next = new Node(2)\nhead.next.next = new Node(3)\nhead.next.next.next = new Node(4)\nhead.next.next.next.next = new Node(5)\n\nconsole.log(`Middle Node: ${findMiddleOfLinkedList(head).value}`)\n\nhead.next.next.next.next.next = new Node(6)\nconsole.log(`Middle Node: ${findMiddleOfLinkedList(head).value}`)\n\nhead.next.next.next.next.next.next = new Node(7)\nconsole.log(`Middle Node: ${findMiddleOfLinkedList(head).value}`)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The above algorithm will have a time complexity of ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is the number of nodes in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-palindrome-linkedlist-medium"},"\ud83c\udf1f Palindrome LinkedList (medium)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/palindrome-linked-list/"},"https://leetcode.com/problems/palindrome-linked-list/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given the head of a ",(0,a.kt)("b",null,"Singly LinkedList"),", write a method to check if the ",(0,a.kt)("b",null,"LinkedList is a palindrome")," or not."),(0,a.kt)("p",{parentName:"blockquote"},"Your algorithm should use ",(0,a.kt)("b",null,"constant space")," and the input ",(0,a.kt)("b",null,"LinkedList")," should be in the original form once the algorithm is finished. The algorithm should have ",(0,a.kt)("inlineCode",{parentName:"p"},"O(N)")," time complexity where ",(0,a.kt)("inlineCode",{parentName:"p"},"N")," is the number of nodes in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("h3",{parentName:"blockquote",id:"example-1"},"Example 1:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre"},"Input: 2 -> 4 -> 6 -> 4 -> 2 -> null\nOutput: true\n")),(0,a.kt)("h3",{parentName:"blockquote",id:"example-2"},"Example 2:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre"},"Input: 2 -> 4 -> 6 -> 4 -> 2 -> 2 -> null\nOutput: false\n"))),(0,a.kt)("p",null,"As we know, a palindrome ",(0,a.kt)("b",null,"LinkedList")," will have nodes values that read the same backward or forward. This means that if we divide the ",(0,a.kt)("b",null,"LinkedList")," into two halves, the node values of the first half in the forward direction should be similar to the node values of the second half in the backward direction. As we have been given a Singly ",(0,a.kt)("b",null,"LinkedList"),", we can\u2019t move in the backward direction. To handle this, we will perform the following steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We can use the ",(0,a.kt)("b",null,"Fast & Slow pointers")," method similar to ",(0,a.kt)("b",null,"Middle of the LinkedList")," to find the middle node of the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ol"},"Once we have the middle of the ",(0,a.kt)("b",null,"LinkedList"),", we will reverse the second half."),(0,a.kt)("li",{parentName:"ol"},"Then, we will compare the first half with the reversed second half to see if the ",(0,a.kt)("b",null,"LinkedList")," represents a palindrome."),(0,a.kt)("li",{parentName:"ol"},"Finally, we will reverse the second half of the ",(0,a.kt)("b",null,"LinkedList")," again to revert and bring the ",(0,a.kt)("b",null,"LinkedList")," back to its original form.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Node {\n  constructor(value, next = null) {\n    this.value = value\n    this.next = next\n  }\n}\n\nfunction isPalindromicLinkedList(head) {\n  if(head === null || head.next === null) {\n    return true\n  }\n  \n  //find the middle of the LinkedList\n  let slow = head\n  let fast = head\n  \n  while((fast !== null && fast.next !== null)) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  \n  //reverse the second half\n  let headSecondHalf = reverse(slow)\n  \n  //store the head of reversed part to revert back later\n  let copyHeadSecondHalf = headSecondHalf\n  \n  //compare first and second half\n  while((head !== null && headSecondHalf !== null)){\n    if(head.value !== headSecondHalf.value) {\n      //not a palindrome\n      break\n    }\n    \n    head = head.next\n    headSecondHalf = headSecondHalf.next\n  }\n  \n  //revert the reverse of the second half\n  reverse(copyHeadSecondHalf)\n  \n  //if both halves match\n  if(head === null || headSecondHalf === null) {\n    return true\n  }\n  \n  return false\n}\n\n\nfunction reverse(head) {\n  let prev = null\n  \n  while (head !== null) {\n    let next = head.next\n    head.next = prev\n    prev = head\n    head = next\n  }\n  return prev\n}\nhead = new Node(2)\nhead.next = new Node(4)\nhead.next.next = new Node(6)\nhead.next.next.next = new Node(4)\nhead.next.next.next.next = new Node(2)\n\nconsole.log(`Is palindrome: ${isPalindromicLinkedList(head)}`)\n\nhead.next.next.next.next.next = new Node(2)\nconsole.log(`Is palindrome: ${isPalindromicLinkedList(head)}`)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The above algorithm will have a time complexity of ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is the number of nodes in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-rearrange-a-linkedlist-medium"},"\ud83c\udf1f Rearrange a LinkedList (medium)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/reorder-list/"},"https://leetcode.com/problems/reorder-list/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given the head of a Singly ",(0,a.kt)("b",null,"LinkedList"),", write a method to modify the ",(0,a.kt)("b",null,"LinkedList")," such that the ",(0,a.kt)("b",null,"nodes from the second half of the ",(0,a.kt)("b",null,"LinkedList")," are inserted alternately to the nodes from the first half in reverse order"),". So if the ",(0,a.kt)("b",null,"LinkedList")," has nodes ",(0,a.kt)("inlineCode",{parentName:"p"},"1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null"),", your method should return ",(0,a.kt)("inlineCode",{parentName:"p"},"1 -> 6 -> 2 -> 5 -> 3 -> 4 -> null"),".")),(0,a.kt)("h3",{id:"example-1-1"},"Example 1:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: 2 -> 4 -> 6 -> 8 -> 10 -> 12 -> null\nOutput: 2 -> 12 -> 4 -> 10 -> 6 -> 8 -> null \n")),(0,a.kt)("h3",{id:"example-2-1"},"Example 2:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: 2 -> 4 -> 6 -> 8 -> 10 -> null\nOutput: 2 -> 10 -> 4 -> 8 -> 6 -> null\n")),(0,a.kt)("p",null,"This problem shares similarities with ",(0,a.kt)("b",null,"Palindrome LinkedList"),". To rearrange the given ",(0,a.kt)("b",null,"LinkedList")," we will follow the following steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We can use the ",(0,a.kt)("b",null,"Fast & Slow pointers")," method similar to ",(0,a.kt)("b",null,"Middle of the ",(0,a.kt)("b",null,"LinkedList"))," to find the middle node of the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ol"},"Once we have the middle of the ",(0,a.kt)("b",null,"LinkedList"),", we will reverse the second half of the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ol"},"Finally, we\u2019ll iterate through the first half and the reversed second half to produce a ",(0,a.kt)("b",null,"LinkedList")," in the required order.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'class Node {\n  constructor (val, next = null) {\n    this.val = val\n    this.next = next\n  }\n  \n  printList() {\n    let result = "";\n    let temp = this;\n    while (temp !== null) {\n      result += temp.val + " ";\n      temp = temp.next;\n    }\n    console.log(result);\n  }\n}\n\n\nfunction reorder (head) {\n  if(head === null || head.next === null) {\n    return true\n  }\n  \n  //find the middle of the LinkedList\n  let slow = head\n  let fast = head\n  \n  while (fast !== null && fast.next !== null) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  \n  //slow is now pointing to the middle node\n  headSecondHalf = reverse(slow)\n  //reverse thesecond half\n  headFirstHalf = head\n  \n  //rearrange to produce the LinkList in the required order\n  while(headFirstHalf !== null && headSecondHalf !== null) {\n    let temp = headFirstHalf.next\n    headFirstHalf.next = headSecondHalf\n    headFirstHalf = temp\n    \n    temp = headSecondHalf.next\n    headSecondHalf.next = headFirstHalf\n    headSecondHalf = temp\n  }\n  \n  //set the next of the last node to \'null\'\n  if(headFirstHalf!== null) {\n    headFirstHalf.next = null\n  }\n}\n\n\nfunction reverse(head) {\n  let prev = null\n  \n  while(head !== null) {\n    let next = head.next\n    head.next = prev\n    prev = head\n    head = next\n  }\n  \n  return prev\n  \n}\nhead = new Node(2)\nhead.next = new Node(4)\nhead.next.next = new Node(6)\nhead.next.next.next = new Node(8)\nhead.next.next.next.next = new Node(10)\nhead.next.next.next.next.next = new Node(12)\nreorder(head)\nhead.printList()\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The above algorithm will have a time complexity of ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is the number of nodes in the ",(0,a.kt)("b",null,"LinkedList"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-cycle-in-a-circular-array-hard"},"\ud83c\udf1f Cycle in a Circular Array (hard)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/circular-array-loop/"},"https://leetcode.com/problems/circular-array-loop/")),(0,a.kt)("p",null,"We are given an array containing positive and negative numbers. Suppose the array contains a number ",(0,a.kt)("inlineCode",{parentName:"p"},"M")," at a particular index. Now, if ",(0,a.kt)("inlineCode",{parentName:"p"},"M")," is positive we will move forward ",(0,a.kt)("inlineCode",{parentName:"p"},"M")," indices and if ",(0,a.kt)("inlineCode",{parentName:"p"},"M")," is negative move backwards ",(0,a.kt)("inlineCode",{parentName:"p"},"M")," indices. You should assume that the ",(0,a.kt)("b",null,"array is circular")," which means two things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If, while moving forward, we reach the end of the array, we will jump to the first element to continue the movement."),(0,a.kt)("li",{parentName:"ol"},"If, while moving backward, we reach the beginning of the array, we will jump to the last element to continue the movement.\nWrite a method to determine ",(0,a.kt)("b",null,"if the array has a cycle"),". The  ",(0,a.kt)("i",null,"cycle"),"  should have more than one element and should follow one direction which means the  ",(0,a.kt)("i",null,"cycle"),"  should not contain both forward and backward movements.")),(0,a.kt)("h3",{id:"example-1-2"},"Example 1:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: [1, 2, -1, 2, 2]\nOutput: true\nExplanation: The array has a cycle among indices: 0 -> 1 -> 3 -> 0\n")),(0,a.kt)("h3",{id:"example-2-2"},"Example 2:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: [2, 2, -1, 2]\nOutput: true\nExplanation: The array has a cycle among indices: 1 -> 3 -> 1\n")),(0,a.kt)("h3",{id:"example-3"},"Example 3:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: [2, 1, -1, -2]\nOutput: false\nExplanation: The array does not have any cycle.\n")),(0,a.kt)("p",null,"This problem involves finding a  ",(0,a.kt)("i",null,"cycle"),"  in the array and, as we know, the ",(0,a.kt)("b",null,"Fast & Slow pointer")," method is an efficient way to do that. We can start from each index of the array to find the cycle. If a number does not have a  ",(0,a.kt)("i",null,"cycle"),"  we will move forward to the next element. There are a couple of additional things we need to take care of:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"As mentioned in the problem, the  ",(0,a.kt)("i",null,"cycle"),"  should have more than one element. This means that when we move a pointer forward, if the pointer points to the same element after the move, we have a one-element cycle. Therefore, we can finish our  ",(0,a.kt)("i",null,"cycle"),"  search for the current element.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The other requirement mentioned in the problem is that the  ",(0,a.kt)("i",null,"cycle"),"  should not contain both forward and backward movements. We will handle this by remembering the direction of each element while searching for the cycle. If the number is positive, the direction will be forward and if the number is negative, the direction will be backward. So whenever we move a pointer forward, if there is a change in the direction, we will finish our  ",(0,a.kt)("i",null,"cycle"),"  search right there for the current element."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function circularArrayLoopExists(arr) {\n  for(let i = 0; i < arr.length; i++) {\n    //if we are moving forward or not\n    let isForward = arr[i] >= 0\n    let slow = i\n    let fast = i\n    \n    //if slow or fast becomes -1 this means we can't find cycle for this number\n    while(true) {\n      // move one step for slow pointer\n      slow = findNextIndex(arr, isForward, slow)\n      //move one step for fast pointer\n      fast = findNextIndex(arr, isForward, fast)\n      if(fast !== -1){\n        //move another step for the fast pointer\n        fast = findNextIndex(arr, isForward, fast)\n      }\n      if(slow === -1 || fast === -1 || slow === fast){\n        break\n      }  \n    }\n    \n    if(slow !== -1 && slow === fast){\n      return true\n    }\n  } \n  return false\n}\n\nfunction findNextIndex(arr, isForward, currentIndex) {\n  let direction = arr[currentIndex] >= 0\n  \n  if(isForward !== direction){\n    //change indirection, return -1\n    return -1\n  }\n  \n  nextIndex = (currentIndex + arr[currentIndex]) % arr.length\n  if(nextIndex < 0) {\n    //wrap around for negative numbers\n    nextIndex += arr.length\n  }\n  \n  //one element cycle, return -1\n  if(nextIndex === currentIndex){\n    nextIndex = -1\n  }\n  \n  return nextIndex\n}\n\ncircularArrayLoopExists([1, 2, -1, 2, 2])\ncircularArrayLoopExists([2, 2, -1, 2])\ncircularArrayLoopExists([2, 1, -1, -2])\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The above algorithm will have a time complexity of ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N\xb2)")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"N")," is the number of elements in the array. This complexity is due to the fact that we are iterating all elements of the array and trying to find a  ",(0,a.kt)("i",null,"cycle"),"  for each element."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h4",{id:"an-alternate-approach"},"An Alternate Approach"),(0,a.kt)("p",null,"In our algorithm, we don\u2019t keep a record of all the numbers that have been evaluated for  ",(0,a.kt)("i",null,"cycle")," . We know that all such numbers will not produce a  ",(0,a.kt)("i",null,"cycle"),"  for any other instance as well. If we can remember all the numbers that have been visited, our algorithm will improve to ",(0,a.kt)("inlineCode",{parentName:"p"},"O(N)")," as, then, each number will be evaluated for  ",(0,a.kt)("i",null,"cycle"),"  only once. We can keep track of this by creating a separate array, however, in this case, the space complexity of our algorithm will increase to ",(0,a.kt)("inlineCode",{parentName:"p"},"O(N)"),"."))}u.isMDXComponent=!0}}]);
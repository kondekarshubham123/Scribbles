"use strict";(self.webpackChunkscribbles=self.webpackChunkscribbles||[]).push([[3135],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=i.createContext({}),m=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=m(e.components);return i.createElement(o.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=m(t),h=a,d=p["".concat(o,".").concat(h)]||p[h]||c[h]||r;return t?i.createElement(d,l(l({ref:n},u),{},{components:t})):i.createElement(d,l({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=h;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[p]="string"==typeof e?e:a,l[1]=s;for(var m=2;m<r;m++)l[m]=t[m];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6412:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var i=t(7462),a=(t(7294),t(3905));const r={},l="Pattern 5: Cyclic Sort",s={unversionedId:"category/notes/\u2705  Pattern 05: Cyclic Sort",id:"category/notes/\u2705  Pattern 05: Cyclic Sort",title:"Pattern 5: Cyclic Sort",description:"This pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range.",source:"@site/dsa/category/notes/\u2705  Pattern 05: Cyclic Sort.md",sourceDirName:"category/notes",slug:"/category/notes/\u2705  Pattern 05: Cyclic Sort",permalink:"/Scribbles/dsa/category/notes/\u2705  Pattern 05: Cyclic Sort",draft:!1,editUrl:"https://github.com/kondekarshubham123/Scribbles/tree/main/dsa/category/notes/\u2705  Pattern 05: Cyclic Sort.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pattern 4 : Merge Intervals",permalink:"/Scribbles/dsa/category/notes/\u2705  Pattern 04 : Merge Intervals"}},o={},m=[{value:"For example, take the following problem:",id:"for-example-take-the-following-problem",level:3},{value:"Cyclic Sort (easy)",id:"cyclic-sort-easy",level:2},{value:"Find the Missing Number (easy)",id:"find-the-missing-number-easy",level:2},{value:"Find all Missing Numbers (easy)",id:"find-all-missing-numbers-easy",level:2},{value:"Find the Duplicate Number (easy)",id:"find-the-duplicate-number-easy",level:2},{value:"Find all Duplicate Numbers (easy)",id:"find-all-duplicate-numbers-easy",level:2},{value:"\ud83c\udf1f Find the Corrupt Pair (easy)",id:"-find-the-corrupt-pair-easy",level:2},{value:"\ud83c\udf1f Find the Smallest Missing Positive Number (medium)",id:"-find-the-smallest-missing-positive-number-medium",level:2},{value:"\ud83c\udf1f Find the First K Missing Positive Numbers (hard)",id:"-find-the-first-k-missing-positive-numbers-hard",level:2}],u={toc:m};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pattern-5-cyclic-sort"},"Pattern 5: Cyclic Sort"),(0,a.kt)("p",null,"This pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range."),(0,a.kt)("h3",{id:"for-example-take-the-following-problem"},"For example, take the following problem:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You are given an unsorted array containing numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," The array can have duplicates, which means that some numbers will be missing. Find all the missing numbers.")),(0,a.kt)("p",null,"To efficiently solve this problem, we can use the fact that the input array contains numbers in the range of ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),".\nFor example, to efficiently sort the array, we can try placing each number in its correct place, i.e., placing ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," at index ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", placing ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," at index ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", and so on. Once we are done with the sorting, we can iterate the array to find all indices that are missing the correct numbers. These will be our required numbers."),(0,a.kt)("h2",{id:"cyclic-sort-easy"},"Cyclic Sort (easy)"),(0,a.kt)("p",null,"We are given an array containing ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," objects. Each object, when created, was assigned a unique number from ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," based on their creation sequence. This means that the object with sequence number ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," was created just before the object with sequence number ",(0,a.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Write a function to sort the objects ",(0,a.kt)("i",null,"in-place")," on their creation sequence number in ",(0,a.kt)("inlineCode",{parentName:"p"},"O(n)")," and without any extra space.")),(0,a.kt)("p",null,"For simplicity, let\u2019s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.\nAs we know, the input array contains numbers in the range of ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". We can use this fact to devise an efficient way to sort the numbers. Since all numbers are unique, we can try placing each number at its correct place, i.e., placing ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," at index ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", placing ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," at index ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),", and so on."),(0,a.kt)("p",null,"To place a number (or an object in general) at its correct index, we first need to find that number. If we first find a number and then place it at its correct place, it will take us ",(0,a.kt)("inlineCode",{parentName:"p"},"O(N\xb2)"),", which is not acceptable."),(0,a.kt)("p",null,"Instead, what if we iterate the array one number at a time, and if the current number we are iterating is not at the correct index, we swap it with the number at its correct index. This way we will go through all numbers and place them in their correct indices, hence, sorting the whole array."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function cyclicSort(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const j = nums[i] - 1; //nums[i] = 3, 3-1 = 2\n    if (nums[i] !== nums[j]) {\n      //3 !== 2\n      //swap\n      // [nums[i], nums[j]] = [nums[j], nums[i]]\n      let temp = nums[i];\n      nums[i] = nums[j];\n      nums[j] = temp;\n    } else {\n      i++;\n    }\n  }\n  return nums;\n}\n\ncyclicSort([3, 1, 5, 4, 2]);\ncyclicSort([2, 6, 4, 3, 1, 5]);\ncyclicSort([1, 5, 6, 4, 3, 2]);\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),". Although we are not incrementing the index ",(0,a.kt)("inlineCode",{parentName:"li"},"i")," when swapping the numbers, this will result in more than ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," iterations of the loop, but in the worst-case scenario, the while loop will swap a total of ",(0,a.kt)("inlineCode",{parentName:"li"},"n-1")," numbers and once a number is at its correct index, we will move on to the next number by incrementing ",(0,a.kt)("inlineCode",{parentName:"li"},"i"),". So overall, our algorithm will take ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n) + O(n-1)")," which is asymptotically equivalent to ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"find-the-missing-number-easy"},"Find the Missing Number (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/missing-number/"},"https://leetcode.com/problems/missing-number/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We are given an array containing ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," distinct numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". Since the array has only ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," numbers out of the total ",(0,a.kt)("inlineCode",{parentName:"p"},"n+1")," numbers, find the missing number.")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern")),". Since the input array contains unique numbers from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),", we can use a similar strategy as discussed in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," to place the numbers on their correct index. Once we have every number in its correct place, we can iterate the array to find the index which does not have the correct number, and that index will be our missing number."),(0,a.kt)("p",null,"However, there are two differences with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort")),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"In this problem, the numbers are ranged from ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"n"),", compared to ",(0,a.kt)("inlineCode",{parentName:"li"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," in the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"li",href:"#pattern-5-cyclic-sort"},"Cyclic Sort")),". This will make two changes in our algorithm:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"In this problem, each number should be equal to its index, compared to ",(0,a.kt)("inlineCode",{parentName:"li"},"index - 1")," in the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"li",href:"#pattern-5-cyclic-sort"},"Cyclic Sort")),". Therefore => ",(0,a.kt)("inlineCode",{parentName:"li"},"nums[i] == nums[nums[i]]")),(0,a.kt)("li",{parentName:"ul"},"Since the array will have ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," numbers, which means array indices will range from ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"n-1"),". Therefore, we will ignore the number ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," as we can\u2019t place it in the array, so => ",(0,a.kt)("inlineCode",{parentName:"li"},"nums[i] < nums.length")))),(0,a.kt)("li",{parentName:"ol"},"Say we are at index ",(0,a.kt)("inlineCode",{parentName:"li"},"i"),". If we swap the number at index ",(0,a.kt)("inlineCode",{parentName:"li"},"i")," to place it at the correct index, we can still have the wrong number at index ",(0,a.kt)("inlineCode",{parentName:"li"},"i"),". This was true in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"li",href:"#pattern-5-cyclic-sort"},"Cyclic Sort"))," too. It didn\u2019t cause any problems in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"li",href:"#pattern-5-cyclic-sort"},"Cyclic Sort"))," as over there, we made sure to place one number at its correct place in each step, but that wouldn\u2019t be enough in this problem as we have one extra number due to the larger range. Therefore, we will not move to the next number after the swap until we have a correct number at the index ",(0,a.kt)("inlineCode",{parentName:"li"},"i"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findMissingNumber(nums) {\n  let i = 0;\n  const n = nums.length;\n\n  //sort first\n  while (i < n) {\n    let j = nums[i];\n    if (nums[i] < n && nums[i] !== nums[j]) {\n      //0 < 4 && 0 !== 4\n      //swap\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  //find the first number missing from it's index\n  //that will be our required number\n  for (i = 0; i < n; i++) {\n    if (nums[i] !== i) {\n      return i;\n    }\n  }\n  return n;\n}\n\nfindMissingNumber([4, 0, 3, 1]); //2\nfindMissingNumber([8, 3, 5, 2, 4, 6, 0, 1]); //7\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),". In the while loop, although we are not incrementing the index ",(0,a.kt)("inlineCode",{parentName:"li"},"i")," when swapping the numbers, this will result in more than ",(0,a.kt)("inlineCode",{parentName:"li"},"n")," iterations of the loop, but in the worst-case scenario, the while loop will swap a total of ",(0,a.kt)("inlineCode",{parentName:"li"},"n-1")," numbers and once a number is at its correct index, we will move on to the next number by incrementing ",(0,a.kt)("inlineCode",{parentName:"li"},"i"),". In the end, we iterate the input array again to find the first number missing from its index, so overall, our algorithm will take ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n) + O(n-1) + O(n)")," which is asymptotically equivalent to ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"find-all-missing-numbers-easy"},"Find all Missing Numbers (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/"},"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We are given an unsorted array containing numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". The array can have duplicates, which means some numbers will be missing. Find all those missing numbers.")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," and shares similarities with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number"))," with one difference. In this problem, there can be many duplicates whereas in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number"))," there were no duplicates and the range was greater than the length of the array."),(0,a.kt)("p",null,"However, we will follow a similar approach though as discussed in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number"))," to place the numbers on their correct indices. Once we are done with the ",(0,a.kt)("b",null,"Cyclic Sort")," we will iterate the array to find all indices that are missing the correct numbers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findMissingNumbers(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const j = nums[i] - 1;\n\n    if (nums[i] !== nums[j]) {\n      //swap\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  let missingNumbers = [];\n\n  for (i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      missingNumbers.push(i + 1);\n    }\n  }\n\n  return missingNumbers;\n}\n\nfindMissingNumbers([2, 3, 1, 8, 2, 3, 5, 1]); //[4, 6, 7], The array should have all numbers from 1 to 8, due to duplicates 4, 6, and 7 are missing.\nfindMissingNumbers([2, 4, 1, 2]); //3\nfindMissingNumbers([2, 3, 2, 1]); //4\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"Ignoring the space required for the output array, the algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"find-the-duplicate-number-easy"},"Find the Duplicate Number (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/find-the-duplicate-number/"},"https://leetcode.com/problems/find-the-duplicate-number/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We are given an unsorted array containing ",(0,a.kt)("inlineCode",{parentName:"p"},"n+1")," numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"to",(0,a.kt)("inlineCode",{parentName:"p"},"n")," The array has only one duplicate but it can be repeated multiple times. ",(0,a.kt)("b",null,"Find that duplicate number without using any extra space"),". You are, however, allowed to modify the input array.")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," and shares similarities with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number")),". Following a similar approach, we will try to place each number on its correct index. Since there is only one duplicate, if while swapping the number with its index both the numbers being swapped are same, we have found our duplicate!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findDuplicate(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    if (nums[i] !== i + 1) {\n      let j = nums[i] - 1;\n      if (nums[i] !== nums[j]) {\n        //swap\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n      } else {\n        //we have found the duplicate\n        return nums[i];\n      }\n    } else {\n      i++;\n    }\n  }\n  return -1;\n}\n\nfindDuplicate([1, 4, 4, 3, 2]); //4\nfindDuplicate([2, 1, 3, 3, 5, 4]); //3\nfindDuplicate([2, 4, 1, 4, 4]); //4\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)")," but modifies the input array.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Can we solve the above problem in ",(0,a.kt)("inlineCode",{parentName:"p"},"O(1)")," space and without modifying the input array?")),(0,a.kt)("p",null,"While doing the ",(0,a.kt)("b",null,"Cyclic Sort"),", we realized that the array will have a cycle due to the duplicate number and that the start of the cycle will always point to the duplicate number. This means that we can use the ",(0,a.kt)("b",null,"fast & the slow")," pointer method to find the duplicate number or the start of the cycle similar to ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/Chanda-Abdul/Several-Coding-Patterns-for-Solving-Data-Structures-and-Algorithms-Problems-during-Interviews/blob/main/%E2%9C%85%20%20Pattern%2003:%20Fast%20%26%20Slow%20pointers.md#start-of-linkedlist-cycle-medium"},"Start of LinkedList Cycle")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findDuplicate(nums) {\n  //using fast & slow pointer method\n  let slow = nums[0];\n  let fast = nums[nums[0]];\n  while (slow !== fast) {\n    slow = nums[slow];\n    fast = nums[nums[fast]];\n  }\n  //find the cycle length\n  let current = nums[nums[slow]];\n  let cycleLength = 1;\n  while (current !== nums[slow]) {\n    current = nums[current];\n    cycleLength++;\n  }\n\n  return findStart(nums, cycleLength);\n}\n\nfunction findStart(nums, cycleLength) {\n  let pointer1 = nums[0];\n  let pointer2 = nums[0];\n  //move pointer2 ahead by cycleLength steps\n  while (cycleLength > 0) {\n    pointer2 = nums[pointer2];\n    cycleLength--;\n  }\n  //increment both pointers until they meet at the start of the cycle\n  while (pointer1 !== pointer2) {\n    pointer1 = nums[pointer1];\n    pointer2 = nums[pointer2];\n  }\n\n  return pointer1;\n}\n\nfindDuplicate([1, 4, 4, 3, 2]); //4\nfindDuplicate([2, 1, 3, 3, 5, 4]); //3\nfindDuplicate([2, 4, 1, 4, 4]); //4\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)")," and the space complexity is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"find-all-duplicate-numbers-easy"},"Find all Duplicate Numbers (easy)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/find-all-duplicates-in-an-array/"},"https://leetcode.com/problems/find-all-duplicates-in-an-array/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We are given an unsorted array containing ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". The array has some numbers appearing twice, ",(0,a.kt)("b",null,"find all these duplicate numbers without using any extra space"),".")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," and shares similarities with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-all-duplicate-numbers-easy"},"Find the Duplicate Number")),". Following a similar approach, we will place each number at its correct index. After that, we will iterate through the array to find all numbers that are not at the correct indices. All these numbers are duplicates."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findAllDuplicates(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    //??\n    let j = nums[i] - 1;\n\n    if (nums[i] !== nums[j]) {\n      //swap\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  let duplicateNumbers = [];\n\n  for (i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      //we have found the duplicate\n      duplicateNumbers.push(nums[i]);\n    }\n  }\n\n  return duplicateNumbers;\n}\n\nfindAllDuplicates([3, 4, 4, 5, 5]); //[4, 5]\nfindAllDuplicates([5, 4, 7, 2, 3, 5, 3]); //[3, 5]\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"Ignoring the space required for storing the duplicates, the algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-find-the-corrupt-pair-easy"},"\ud83c\udf1f Find the Corrupt Pair (easy)"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We are given an unsorted array containing ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," numbers taken from the range ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". The array originally contained all the numbers from ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),", but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findCorruptNumbers(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const j = nums[i] - 1;\n    if (nums[i] !== nums[j]) {\n      //swap\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  //output => duplicate number(nums[i]) and the missing number(i+1)\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      return [nums[i], i + 1];\n    }\n  }\n  return [-1, -1];\n}\n\nfindCorruptNumbers([3, 1, 2, 5, 2]); //[2, 4], '2' is duplicated and '4' is missing.\nfindCorruptNumbers([3, 1, 2, 3, 6, 4]); // [3, 5], '3' is duplicated and '5' is missing.\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-find-the-smallest-missing-positive-number-medium"},"\ud83c\udf1f Find the Smallest Missing Positive Number (medium)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/first-missing-positive/"},"https://leetcode.com/problems/first-missing-positive/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given an unsorted array containing numbers, find the ",(0,a.kt)("b",null,"smallest missing positive number")," in it.")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," and shares similarities with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number"))," with one big difference. In this problem, the numbers are not bound by any range so we can have any number in the input array."),(0,a.kt)("p",null,"However, we will follow a similar approach though as discussed in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#find-the-missing-number-easy"},"Find the Missing Number"))," to place the numbers on their correct indices and ignore all numbers that are out of the range of the array (i.e., all negative numbers and all numbers greater than or equal to the length of the array). Once we are done with the ",(0,a.kt)("b",null,"Cyclic Sort")," we will iterate the array and the first index that does not have the correct number will be the smallest missing positive number!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findFirstSmallestMissingPositive(nums) {\n  //try to sort the array\n  let i = 0;\n  let n = nums.length;\n\n  while (i < n) {\n    const j = nums[i] - 1;\n    if (nums[i] !== nums[j] && nums[i] > 0 && nums[i] <= n) {\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) {\n      return i + 1;\n    }\n  }\n\n  return nums.length + 1;\n}\n\nfindFirstSmallestMissingPositive([-3, 1, 5, 4, 2]); //3, The smallest missing positive number is '3'\nfindFirstSmallestMissingPositive([3, -2, 0, 1, 2]); //4\nfindFirstSmallestMissingPositive([3, 2, 5, 1]); //4\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)"),"."),(0,a.kt)("li",{parentName:"ul"},"The algorithm runs in constant space ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)"),".")),(0,a.kt)("h2",{id:"-find-the-first-k-missing-positive-numbers-hard"},"\ud83c\udf1f Find the First K Missing Positive Numbers (hard)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/kth-missing-positive-number/"},"https://leetcode.com/problems/kth-missing-positive-number/")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given an unsorted array containing numbers and a number ",(0,a.kt)("inlineCode",{parentName:"p"},"K"),", find the first ",(0,a.kt)("inlineCode",{parentName:"p"},"K")," missing positive numbers in the array.")),(0,a.kt)("p",null,"This problem follows the ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#pattern-5-cyclic-sort"},"Cyclic Sort pattern"))," and shares similarities with ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#%F0%9F%8C%9F-find-the-smallest-missing-positive-number-medium"},"Find the Smallest Missing Positive Number")),". The only difference is that, in this problem, we need to find the first ",(0,a.kt)("inlineCode",{parentName:"p"},"K")," missing numbers compared to only the first missing number."),(0,a.kt)("p",null,"We will follow a similar approach as discussed in ",(0,a.kt)("b",null,(0,a.kt)("a",{parentName:"p",href:"#%F0%9F%8C%9F-find-the-smallest-missing-positive-number-medium"},"Find the Smallest Missing Positive Number"))," to place the numbers on their correct indices and ignore all numbers that are out of the range of the array. Once we are done with the ",(0,a.kt)("b",null,"Cyclic Sort")," we will iterate through the array to find indices that do not have the correct numbers."),(0,a.kt)("p",null,"If we are not able to find ",(0,a.kt)("inlineCode",{parentName:"p"},"K")," missing numbers from the array, we need to add additional numbers to the output array. "),(0,a.kt)("p",null,"To find these additional numbers we will use the length of the array. For example, if the length of the array is ",(0,a.kt)("inlineCode",{parentName:"p"},"4"),", the next missing numbers will be ",(0,a.kt)("inlineCode",{parentName:"p"},"4, 5, 6")," and so on. "),(0,a.kt)("p",null,"One tricky aspect is that any of these additional numbers could be part of the array. Remember, while sorting, we ignored all numbers that are greater than or equal to the length of the array. "),(0,a.kt)("p",null,"So all indices that have the missing numbers could possibly have these additional numbers. "),(0,a.kt)("p",null,"To handle this, we must keep track of all numbers from those indices that have missing numbers."),(0,a.kt)("p",null,"Let\u2019s understand this with an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"nums: [2, 1, 3, 6, 5], k =2\n")),(0,a.kt)("p",null,"After the ",(0,a.kt)("b",null,"Cyclic Sort")," our array will look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"nums: [1, 2, 3, 6, 5]\n")),(0,a.kt)("p",null,"From the sorted array we can see that the first missing number is ",(0,a.kt)("inlineCode",{parentName:"p"},"4")," (as we have ",(0,a.kt)("inlineCode",{parentName:"p"},"6")," on the fourth index) but to find the second missing number we need to remember that the array does contain ",(0,a.kt)("inlineCode",{parentName:"p"},"6"),". Hence, the next missing number is ",(0,a.kt)("inlineCode",{parentName:"p"},"7"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function findFirstKMissingPositive(nums, k) {\n  //sort? the input array\n  let i = 0;\n  const n = nums.length;\n\n  while (i < n) {\n    const j = nums[i] - 1;\n    if (nums[i] !== nums[j] && nums[i] <= n && nums[i] > 0) {\n      //swap\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  const missingNumbers = [];\n  const extraNumbers = new Set();\n\n  for (let i = 0; i < n; i++) {\n    if (missingNumbers.length < k) {\n      if (nums[i] !== i + 1) {\n        missingNumbers.push(i + 1);\n        extraNumbers.add(nums[i]);\n      }\n    }\n  }\n\n  //add the remaining missing numbers\n  let j = 1;\n\n  while (missingNumbers.length < k) {\n    const currentNumber = j + n;\n    //ignore if the array contains the current number\n    if (!extraNumbers.has(currentNumber)) {\n      missingNumbers.push(currentNumber);\n    }\n    j++;\n  }\n\n  return missingNumbers;\n}\n\nfindFirstKMissingPositive([3, -1, 4, 5, 5], 3); //[1, 2, 6], The smallest missing positive numbers are 1, 2 and 6.)\nfindFirstKMissingPositive([2, 3, 4], 3); //[1, 5, 6], The smallest missing positive numbers are 1, 5 and 6.\nfindFirstKMissingPositive([-2, -3, 4], 2); //[1, 2], The smallest missing positive numbers are 1 and 2.\nfindFirstKMissingPositive([2, 1, 3, 6, 5], 2); //[4, 7]\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The time complexity of the above algorithm is ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n + k)"),", as the last two for loops will run for ",(0,a.kt)("inlineCode",{parentName:"li"},"O(n)")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"O(k)")," times respectively."),(0,a.kt)("li",{parentName:"ul"},"The algorithm needs ",(0,a.kt)("inlineCode",{parentName:"li"},"O(k)")," space to store the ",(0,a.kt)("inlineCode",{parentName:"li"},"extraNumbers"),".")))}p.isMDXComponent=!0}}]);